from collections import deque

# Moves (up, down, left, right)
moves = {
    'U': -3,  # Up
    'D': 3,   # Down
    'L': -1,  # Left
    'R': 1    # Right
}

# Check valid move
def valid_move(pos, move):
    if move == 'L' and pos % 3 == 0:  # Left edge
        return False
    if move == 'R' and pos % 3 == 2:  # Right edge
        return False
    if move == 'U' and pos < 3:       # Top row
        return False
    if move == 'D' and pos > 5:       # Bottom row
        return False
    return True

# Generate new states
def get_neighbors(state):
    neighbors = []
    zero_pos = state.index(0)

    for move, shift in moves.items():
        if valid_move(zero_pos, move):
            new_state = list(state)
            new_pos = zero_pos + shift
            # Swap blank with adjacent tile
            new_state[zero_pos], new_state[new_pos] = new_state[new_pos], new_state[zero_pos]
            neighbors.append(tuple(new_state))
    return neighbors

# DFS Algorithm
def dfs(start, goal):
    stack = [(start, [])]  # (state, path)
    visited = set()

    while stack:
        state, path = stack.pop()
        if state == goal:
            return path + [state]

        if state in visited:
            continue
        visited.add(state)

        for neighbor in get_neighbors(list(state)):
            if neighbor not in visited:
                stack.append((neighbor, path + [state]))
    return None


# Example usage
start_state = (1,2,3,0,4,6,7,5,8)
goal_state = (1,2,3,4,5,6,7,8,0)

solution = dfs(start_state, goal_state)

if solution:
    print("Solution found! Steps:")
    for step in solution:
        print(step[0:3])
        print(step[3:6])
        print(step[6:9])
        print("----")
else:
    print("No solution found.")
